{
  "name": "Fate Rune (Wyrdruna)",
  "type": "specialability",
  "img": "systems/dsa5/icons/categories/ability_general.webp",
  "system": {
    "description": {
      "value": ""
    },
    "gmdescription": {
      "value": ""
    },
    "APValue": {
      "value": "3"
    },
    "requirements": {
      "value": ""
    },
    "rule": {
      "value": ""
    },
    "maxRank": {
      "value": 20
    },
    "step": {
      "value": 1,
      "circle": "1",
      "canNotMultiply": false
    },
    "category": {
      "value": "magicalsign",
      "sub": 0
    },
    "distribution": "",
    "list": {
      "value": ""
    },
    "effect": {
      "value": ""
    },
    "permanentEffects": false,
    "duration": {
      "value": ""
    }
  },
  "effects": [],
  "folder": null,
  "flags": {
    "dsa5": {
      "onUseEffect": "// This is a system macro used for automation. It is disfunctional without the proper context.\n\n\n(async () => {\n  const { getProperty, setProperty } = foundry.utils;\n  const lang = game.i18n.lang == \"de\" ? \"de\" : \"en\";\n\n  const dict = {\n    de: {\n      titleSpeed: \"Herstellungsgeschwindigkeit\",\n      titleMaterial: \"Material\",\n      speedText: \"Der Träger der Schicksalsrune kann die Rune wie einen Schicksalspunkt einsetzen. Nach dem Einsatz erlischt die Rune.\",\n      speedHeader: \"Herstellungszeit\",\n      speedSlow: \"Langsam\",\n      speedSlowTip: \"4 Tage\",\n      speedFast: \"Schnell\",\n      speedFastTip: \"4 Aktionen\",\n      skillArt: \"Malen & Zeichnen\",\n      skillCloth: \"Stoffbearbeitung\",\n      skillLeather: \"Lederbearbeitung\",\n      skillMetal: \"Metallbearbeitung\",\n      skillStone: \"Steinbearbeitung\",\n      matLeather: \"Lederbearbeitung\",\n      matArt: \"Malen & Zeichnen\",\n      matMetal: \"Metallbearbeitung\",\n      matStone: \"Steinbearbeitung\",\n      matCloth: \"Stoffbearbeitung\",\n      needsActor: \"Dieses Makro benötigt einen Akteur.\",\n      noBlutrune: \"Die SF Blutrunen ist nicht vorhanden – Materialauswahl wird geöffnet.\",\n      blutruneFound: \"SF Blutrunen vorhanden – Geschwindigkeitsauswahl wird geöffnet.\",\n      aspNotEnough: \"Nicht genügend Astralenergie.\",\n      aspConsumed: \"20 AsP abgezogen.\",\n      talentFail: \"Die Handwerksprobe ist misslungen. Prozess beendet.\",\n      attrFail: \"Eigenschaftsprobe misslungen.\",\n      itemName: \"Schicksalsrune (Wyrdruna)\",\n      itemNameDepleted: \"Schicksalsrune (Wyrdruna) [erloschen]\",\n      sfBlutrune: \"Blutrunen\",\n      notifyCreated: \"Rune (geladen) erstellt\",\n      fastOnUseOverridden: \"onUseEffect reduziert: Fate-Point-Check + Itemverbrauch.\",\n      lepSpentInfo: (spent, before, after) => `LeP abgezogen: ${spent} (von ${before} → ${after}).`,\n      neutralName: \"Eigenschaftsprobe: IN/IN/CH\",\n      neutralLabel: \" (Wyrdruna IN/IN/CH)\",\n      effFastSet: (qs, sec) => `Effektdauer (Schnell) gesetzt: QS ${qs} → ${sec} Sekunden.`,\n      effSlowSet: (qs, sec) => `Effektdauer (Langsam) gesetzt: QS ${qs} → ${sec} Sekunden.`,\n      fateSfName: \"Schicksalsrune (Wyrdruna)\"\n    },\n    en: {\n      titleSpeed: \"Manufacturing Speed\",\n      titleMaterial: \"Material\",\n      speedText: \"The bearer of the Fate Rune can use the rune like a Fate Point. After use, the rune extinguishes.\",\n      speedHeader: \"Manufacturing Time\",\n      speedSlow: \"Slow\",\n      speedSlowTip: \"4 days\",\n      speedFast: \"Fast\",\n      speedFastTip: \"4 actions\",\n      skillArt: \"Artistic Ability\",\n      skillCloth: \"Clothworking\",\n      skillLeather: \"Leatherworking\",\n      skillMetal: \"Metalworking\",\n      skillStone: \"Earthencraft\",\n      matLeather: \"Leatherworking\",\n      matArt: \"Artistic Ability\",\n      matMetal: \"Metalworking\",\n      matStone: \"Earthencraft\",\n      matCloth: \"Clothworking\",\n      needsActor: \"This macro requires an actor.\",\n      noBlutrune: \"The Blood Runes SF is missing – opening speed selection.\",\n      blutruneFound: \"Blood Runes SF found – opening speed selection.\",\n      aspNotEnough: \"Not enough Astral Energy.\",\n      aspConsumed: \"20 AE consumed.\",\n      talentFail: \"The crafting check failed. Process aborted.\",\n      attrFail: \"Attribute check failed.\",\n      itemName: \"Fate Rune (Wyrdruna)\",\n      itemNameDepleted: \"Fate Rune (Wyrdruna) [depleted]\",\n      sfBlutrune: \"Blood Runes\",\n      notifyCreated: \"Rune (charged) created\",\n      fastOnUseOverridden: \"onUseEffect minimized: Fate point check + item consumption.\",\n      lepSpentInfo: (spent, before, after) => `LP spent: ${spent} (from ${before} → ${after}).`,\n      neutralName: \"Attribute Check: IN/IN/CH\",\n      neutralLabel: \" (Wyrdruna IN/IN/CH)\",\n      effFastSet: (qs, sec) => `Effect duration (Fast) set: QS ${qs} → ${sec} seconds.`,\n      effSlowSet: (qs, sec) => `Effect duration (Slow) set: QS ${qs} → ${sec} seconds.`,\n      fateSfName: \"Fate Rune (Wyrdruna)\"\n    },\n  }[lang];\n\n  if (!actor) {\n    ui.notifications.warn(dict.needsActor);\n    return;\n  }\n\n  const hasBlutrune = actor.items.some((i) => i.type === \"specialability\" && i.name === dict.sfBlutrune);\n\n  // Compendium: Equipment-Item (nicht die Sonderfähigkeit )\n  async function getCompendiumEquipmentByName(name) {\n    const packs = Array.from(game.packs.values()).filter(p => p?.metadata?.system === \"dsa5\");\n    for (const p of packs) {\n      try {\n        const docs = await p.getDocuments({ name });\n        if (!docs?.length) continue;\n\n        // Versuch: direktes Equipment-Dokument\n        const eqDoc = docs.find(d => (d.type || d?.toObject?.().type) === \"equipment\");\n        if (eqDoc) return eqDoc.toObject();\n\n        // Alternativ: iteriere alle Treffer\n        for (const d of docs) {\n          const raw = d.toObject();\n          if (raw?.type === \"equipment\") return raw;\n        }\n      } catch (e) { /* weiter */ }\n    }\n    // Fallback: Minimal-Equipment\n    return {\n      name,\n      type: \"equipment\",\n      img: \"systems/dsa5/icons/categories/magicalsign.webp\",\n      system: {\n        description: { value: \"\" },\n        gmdescription: { value: \"\" },\n        price: { value: 0 },\n        quantity: { value: 1 },\n        weight: { value: 0 },\n        effect: { value: \"\", attributes: \"\" },\n        equipmentType: { value: \"writing\" },\n        structure: { value: 0, max: 6 },\n        worn: { value: false, wearable: false }\n      },\n      effects: []\n    };\n  }\n\n  function getAsp() {\n    return Number(getProperty(actor, \"system.status.astralenergy.value\")) || 0;\n  }\n  async function consumeAsp20() {\n    const asp = getAsp();\n    if (asp < 20) return false;\n    await actor.update({ \"system.status.astralenergy.value\": asp - 20 });\n    ui.notifications.info(dict.aspConsumed);\n    return true;\n  }\n\n  async function rollSkillByName(skillName) {\n    const skill = actor.items.find(x => x.type === \"skill\" && x.name === skillName);\n    if (!skill) {\n      ui.notifications.error(`${actor.name} ${lang === \"de\" ? \"hat das Talent\" : \"does not have the skill\"} ${skillName}.`);\n      return { success: false, qs: 0 };\n    }\n    const setup = await actor.setupSkill(skill, { subtitle: ` (${dict.itemName})` });\n    setProperty(setup, \"testData.opposable\", false);\n    setProperty(setup, \"options.fastForward\", true);\n    setProperty(setup, \"options.noDialog\", true);\n    setProperty(setup, \"options.render\", false);\n    setProperty(setup, \"options.createMessage\", false);\n\n    const res = await actor.basicTest(setup);\n    const qs = Number(getProperty(res, \"result.qualityStep\")) || 0;\n    return { success: qs > 0, qs };\n  }\n\n  // Fähigkeitswert-Bonus aus SF \"Schicksalsrune (Wyrdruna)\" / \"Fate Rune (Wyrdruna)\" (system.step.value)\n  function getFateRuneLevelBonus() {\n    const sf = actor.items.find(i => i.type === \"specialability\" && i.name === dict.fateSfName);\n    return Number(getProperty(sf, \"system.step.value\")) || 0;\n  }\n\n  // Neutrale IN/IN/CH-Probe mit Bonus auf talentValue.value\n  async function rollAttributeININCH(tokenID, options = {}) {\n    const cls = getDocumentClass(\"Item\");\n    const neutralName = dict.neutralName;\n    const neutralLabel = options?.subtitle ?? dict.neutralLabel;\n\n    const tok = tokenID\n      ?? actor.getActiveTokens?.()?.[0]?.id\n      ?? canvas?.tokens?.controlled?.[0]?.id\n      ?? null;\n\n    const dummySkill = new cls({\n      name: neutralName, type: \"skill\",\n      system: {\n        characteristic1: { value: \"in\" },\n        characteristic2: { value: \"in\" },\n        characteristic3: { value: \"ch\" }\n      }\n    }, { noHook: true });\n\n    const setupData = await actor.setupSkill(dummySkill, { ...options, subtitle: neutralLabel }, tok);\n\n    const tlvPath = \"testData.source.system.talentValue.value\";\n    const currentTLV = Number(getProperty(setupData, tlvPath)) || 0;\n    const fwBonus = getFateRuneLevelBonus();\n    setProperty(setupData, tlvPath, currentTLV + fwBonus);\n\n    setProperty(setupData, \"testData.opposable\", false);\n    setProperty(setupData, \"options.fastForward\", true);\n    setProperty(setupData, \"options.noDialog\", true);\n    setProperty(setupData, \"options.render\", false);\n    setProperty(setupData, \"options.createMessage\", false);\n\n    const res = await actor.basicTest(setupData);\n    const qs =\n      Number(getProperty(res, \"result.qualityStep\")) ||\n      Number(getProperty(res, \"qualityStep\")) ||\n      Number(getProperty(res, \"qs\")) || 0;\n\n    return { ...res, result: { ...(res.result ?? {}), qualityStep: qs } };\n  }\n\n  // Schnell-Pfad: LeP IMMER abziehen – auch bei Fehlschlag der Handwerksprobe\n  async function spendLePFastPathAlways() {\n    const roll = await new Roll(\"1d3+1\").evaluate();\n    const damage = Number(roll.total) || 0;\n    if (damage <= 0) return;\n\n    if (typeof actor.applyDamage === \"function\") {\n      try {\n        const before = Number(getProperty(actor, \"system.status.wounds.value\")) || 0;\n        const max = Number(getProperty(actor, \"system.status.wounds.max\")) || 0;\n        await actor.applyDamage(damage);\n        const after = Number(getProperty(actor, \"system.status.wounds.value\")) || before;\n        ui.notifications.info(dict.lepSpentInfo(damage, before, Math.min(after, max)));\n        return;\n      } catch (e) { /* Fallback unten */ }\n    }\n\n    const cur = Number(getProperty(actor, \"system.status.wounds.value\")) || 0;\n    const max = Number(getProperty(actor, \"system.status.wounds.max\")) || 0;\n    const targetWounds = Math.min(cur + damage, max);\n    await actor.update({ \"system.status.wounds.value\": targetWounds });\n    ui.notifications.info(dict.lepSpentInfo(damage, cur, targetWounds));\n  }\n\n  // Reduzierter onUseEffect – Nur für die im schnellen Pfad erzeugte Instanz setzen\n  function buildRuneOnUseEffect() {\n    return `\n// This is a system macro used for automation. It is disfunctional without the proper context.\n\n/*\nSchicksalsrune (Wyrdruna) – onUseEffect (Gegenstand)\n- +1 Schicksalspunkt, falls nicht am Maximum\n- Danach verbrauchbaren Gegenstand reduzieren (quantity -1) oder löschen, wenn Menge 1\n- Keine erloschene Rune erzeugen\n*/\n\nconst { getProperty: GP } = foundry.utils;\nconst lang = game.i18n.lang == \"de\" ? \"de\" : \"en\";\nconst dict = {\n  de: {\n    noActor: \"Kein Akteur vorhanden.\",\n    notifyMax: \"Du hast bereits die maximale Anzahl an Schicksalspunkten.\",\n    notifyAdded: \"Schicksalspunkt hinzugefügt.\",\n    notFoundSource: \"Auslösendes Item nicht gefunden.\",\n  },\n  en: {\n    noActor: \"No actor present.\",\n    notifyMax: \"You already have the maximum number of Fate Points.\",\n    notifyAdded: \"Fate Point added.\",\n    notFoundSource: \"Triggering item not found.\",\n  }\n}[lang];\n\nif (!actor) { ui.notifications.warn(dict.noActor); return; }\n\nconst cur = Number(GP(actor, \"system.status.fatePoints.value\")) || 0;\nconst max = Number(GP(actor, \"system.status.fatePoints.max\")) || 0;\n\nif (max && cur >= max) {\n  ui.notifications.info(dict.notifyMax);\n  return;\n}\n\nconst next = max ? Math.min(cur + 1, max) : (cur + 1);\nawait actor.update({ \"system.status.fatePoints.value\": next });\nui.notifications.info(dict.notifyAdded);\n\nlet sourceItem = null;\nif (this && this.parent && this.parent.documentName === \"Item\") {\n  sourceItem = this.parent;\n} else if (this?.item?.id) {\n  sourceItem = actor.items.get(this.item.id) ?? null;\n} else if (this?.item?.name) {\n  sourceItem = actor.items.find(i => i.type === \"equipment\" && i.name === this.item.name) ?? null;\n}\n\nif (!sourceItem) { ui.notifications.warn(dict.notFoundSource); return; }\n\nconst qtyPath = \"system.quantity.value\";\nconst hasQty = typeof GP(sourceItem, qtyPath) !== \"undefined\";\nif (hasQty) {\n  const curQty = Number(GP(sourceItem, qtyPath)) || 0;\n  if (curQty > 1) {\n    await sourceItem.update({ [qtyPath]: curQty - 1 });\n  } else {\n    await sourceItem.delete();\n  }\n} else {\n  await sourceItem.delete();\n}\n`.trim();\n  }\n\n  // Schnell-Pfad: Rune erzeugen und onUseEffect der Instanz auf reduzierten Code setzen\n  async function addLoadedRuneWithFastArgs3AndDuration(finalQS_HW, finalQS_IN) {\n    const obj = await getCompendiumEquipmentByName(dict.itemName);\n    if (!obj || obj.type !== \"equipment\") {\n      ui.notifications.error(`Item vom Typ 'equipment' nicht gefunden: ${dict.itemName}`);\n      return;\n    }\n\n    // Pflichtfelder\n    if (!Number.isFinite(Number(getProperty(obj, \"system.quantity.value\"))))\n      setProperty(obj, \"system.quantity.value\", 1);\n    if (!Number.isFinite(Number(getProperty(obj, \"system.structure.max\"))))\n      setProperty(obj, \"system.structure.max\", 6);\n    const spValue = Math.max(0, Number(finalQS_HW) || 0);\n    setProperty(obj, \"system.structure.value\", spValue);\n    if (!getProperty(obj, \"system.equipmentType.value\"))\n      setProperty(obj, \"system.equipmentType.value\", \"writing\");\n\n    // Dauer über ersten Effekt\n    let effects = Array.isArray(obj.effects) ? obj.effects : [];\n    if (effects.length === 0) {\n      effects.push({\n        name: dict.itemName,\n        img: obj.img || \"icons/svg/aura.svg\",\n        changes: [],\n        duration: {},\n        flags: { dsa5: {} },\n        disabled: false,\n        transfer: false\n      });\n    }\n    const qsIN = Math.max(0, Number(finalQS_IN) || 0);\n    const qsHW = Math.max(0, Number(finalQS_HW) || 0);\n    const seconds = Math.min(qsIN, qsHW) * 600;\n    setProperty(effects[0], \"duration.seconds\", seconds);\n    setProperty(effects[0], \"duration.startTime\", game.time.worldTime);\n    setProperty(obj, \"effects\", effects);\n\n    // Item einfügen\n    let createdItem = null;\n    try {\n      await actor.sheet._addLoot(obj);\n      // Erzeugte Instanz auffinden\n      createdItem = actor.items.find(i =>\n        i.type === \"equipment\" &&\n        i.name === dict.itemName &&\n        Number(getProperty(i, \"system.structure.value\")) === spValue\n      ) || null;\n    } catch (e) {\n      try {\n        delete obj._id;\n        const created = await actor.createEmbeddedDocuments(\"Item\", [obj]);\n        createdItem = created?.[0] || null;\n      } catch (ee) {\n        ui.notifications.error(lang === \"de\" ? \"Rune konnte nicht hinzugefügt werden.\" : \"Could not add rune.\");\n        console.error(ee);\n        return;\n      }\n    }\n\n    // NUR die Instanz überschreiben: flags.dsa5.onUseEffect → reduzierter Code\n    if (createdItem) {\n      const onUseReduced = buildRuneOnUseEffect();\n      await createdItem.update({ \"flags.dsa5.onUseEffect\": onUseReduced });\n      ui.notifications.info(dict.fastOnUseOverridden);\n    }\n\n    ui.notifications.info(dict.effFastSet(Math.min(qsIN, qsHW), seconds));\n    ui.notifications.info(dict.notifyCreated);\n  }\n\n  // Langsam-Pfad: Rune unverändert aus dem Compendium (kein Override des onUseEffect)\n  async function addLoadedRuneWithSlowDuration(finalQS_HW, finalQS_IN) {\n    const obj = await getCompendiumEquipmentByName(dict.itemName);\n    if (!obj || obj.type !== \"equipment\") {\n      ui.notifications.error(`Item vom Typ 'equipment' nicht gefunden: ${dict.itemName}`);\n      return;\n    }\n\n    if (!Number.isFinite(Number(getProperty(obj, \"system.quantity.value\"))))\n      setProperty(obj, \"system.quantity.value\", 1);\n    if (!Number.isFinite(Number(getProperty(obj, \"system.structure.max\"))))\n      setProperty(obj, \"system.structure.max\", 6);\n    const spValue = Math.max(0, Number(finalQS_HW) || 0);\n    setProperty(obj, \"system.structure.value\", spValue);\n    if (!getProperty(obj, \"system.equipmentType.value\"))\n      setProperty(obj, \"system.equipmentType.value\", \"writing\");\n\n    let effects = Array.isArray(obj.effects) ? obj.effects : [];\n    if (effects.length === 0) {\n      effects.push({\n        name: dict.itemName,\n        img: obj.img || \"icons/svg/aura.svg\",\n        changes: [],\n        duration: {},\n        flags: { dsa5: {} },\n        disabled: false,\n        transfer: false\n      });\n    }\n    const qsIN = Math.max(0, Number(finalQS_IN) || 0);\n    const qsHW = Math.max(0, Number(finalQS_HW) || 0);\n    const seconds = Math.min(qsIN, qsHW) * 2592000;\n    setProperty(effects[0], \"duration.seconds\", seconds);\n    setProperty(effects[0], \"duration.startTime\", game.time.worldTime);\n    setProperty(obj, \"effects\", effects);\n\n    try {\n      await actor.sheet._addLoot(obj);\n    } catch (e) {\n      try {\n        delete obj._id;\n        await actor.createEmbeddedDocuments(\"Item\", [obj]);\n      } catch (ee) {\n        ui.notifications.error(lang === \"de\" ? \"Rune konnte nicht hinzugefügt werden.\" : \"Could not add rune.\");\n        console.error(ee);\n        return;\n      }\n    }\n\n    ui.notifications.info(dict.effSlowSet(Math.min(qsIN, qsHW), seconds));\n    ui.notifications.info(dict.notifyCreated);\n  }\n\n  // Dialoge\n  async function openSpeedDialog() {\n    const dlg = new Dialog({\n      title: dict.titleSpeed,\n      content: `\n        <div>\n          <p>${dict.speedText}</p>\n          <p><b>${dict.speedHeader}</b></p>\n          <div style=\"display:flex; gap:8px;\">\n            <button type=\"button\" class=\"btn-slow\" title=\"${dict.speedSlowTip}\">${dict.speedSlow}</button>\n            <button type=\"button\" class=\"btn-fast\" title=\"${dict.speedFastTip}\">${dict.speedFast}</button>\n          </div>\n        </div>\n      `,\n      buttons: {},\n      render: (html) => {\n        html.find(\".btn-fast\").on(\"click\", async () => {\n          const skillName = dict.skillArt;\n\n          // 1) Handwerksprobe (Malen & Zeichnen)\n          const hw = await rollSkillByName(skillName);\n          const hwSuccess = hw.success;\n          const hwQS = hw.qs;\n          dlg.close();\n\n          // Schnell: LeP IMMER abziehen – auch bei Fehlschlag\n          await spendLePFastPathAlways();\n\n          if (!hwSuccess) {\n            ui.notifications.warn(dict.talentFail);\n            return;\n          }\n\n          // 2) IN/IN/CH-Probe\n          const attrRes = await rollAttributeININCH(actor.getActiveTokens?.()?.[0]?.id, { subtitle: dict.neutralLabel });\n          const attrQS = Number(getProperty(attrRes, \"result.qualityStep\")) || 0;\n          const attrSuccess = attrQS > 0;\n          if (!attrSuccess) { ui.notifications.warn(dict.attrFail); return; }\n\n          // 3) AsP prüfen/abziehen\n          if (getAsp() < 20) { ui.notifications.warn(dict.aspNotEnough); return; }\n          const ok = await consumeAsp20();\n          if (!ok) return;\n\n          // 4) Geladene Rune erzeugen und Instanz-Logik reduzieren\n          await addLoadedRuneWithFastArgs3AndDuration(hwQS, attrQS);\n        });\n\n        html.find(\".btn-slow\").on(\"click\", async () => {\n          dlg.close();\n          await openMaterialDialog();\n        });\n      }\n    });\n    dlg.render(true);\n  }\n\n  async function openMaterialDialog() {\n    const dlg = new Dialog({\n      title: dict.titleMaterial,\n      content: `\n        <div style=\"display:flex; flex-wrap:wrap; gap:6px;\">\n          <button class=\"mat mat-leather\">${dict.matLeather}</button>\n          <button class=\"mat mat-art\">${dict.matArt}</button>\n          <button class=\"mat mat-metal\">${dict.matMetal}</button>\n          <button class=\"mat mat-stone\">${dict.matStone}</button>\n          <button class=\"mat mat-cloth\">${dict.matCloth}</button>\n        </div>\n      `,\n      buttons: {},\n      render: (html) => {\n        const handle = async (skillName) => {\n          const hw = await rollSkillByName(skillName);\n          const hwSuccess = hw.success;\n          const hwQS = hw.qs;\n          dlg.close();\n\n          // Langsam: bei Misslingen sofort beenden (keine AsP, keine Rune)\n          if (!hwSuccess) { ui.notifications.warn(dict.talentFail); return; }\n\n          const attrRes = await rollAttributeININCH(actor.getActiveTokens?.()?.[0]?.id, { subtitle: dict.neutralLabel });\n          const attrQS = Number(getProperty(attrRes, \"result.qualityStep\")) || 0;\n          const attrSuccess = attrQS > 0;\n\n          if (!attrSuccess) { ui.notifications.warn(dict.attrFail); return; }\n          if (getAsp() < 20) { ui.notifications.warn(dict.aspNotEnough); return; }\n          const ok = await consumeAsp20();\n          if (!ok) return;\n\n          // Langsam: Rune unverändert\n          await addLoadedRuneWithSlowDuration(hwQS, attrQS);\n        };\n\n        html.find(\".mat-leather\").on(\"click\", () => handle(dict.skillLeather));\n        html.find(\".mat-art\").on(\"click\", () => handle(dict.skillArt));\n        html.find(\".mat-metal\").on(\"click\", () => handle(dict.skillMetal));\n        html.find(\".mat-stone\").on(\"click\", () => handle(dict.skillStone));\n        html.find(\".mat-cloth\").on(\"click\", () => handle(dict.skillCloth));\n      }\n    });\n    dlg.render(true);\n  }\n\n  if (hasBlutrune) {\n    await openSpeedDialog();\n  } else {\n    await openMaterialDialog();\n  }\n})();\n"
    }
  },
  "_stats": {
    "coreVersion": "13.348",
    "systemId": "dsa5",
    "systemVersion": "7.3.3",
    "createdTime": 1760276176164,
    "modifiedTime": 1760276342310,
    "lastModifiedBy": "muiLafBEaPUcV6uM",
    "exportSource": {
      "worldId": "eng",
      "uuid": "Item.aQujRexrPfJhnQ0t",
      "coreVersion": "13.348",
      "systemId": "dsa5",
      "systemVersion": "7.3.3"
    }
  },
  "ownership": {
    "default": 0
  }
}
